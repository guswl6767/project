<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>Sea Ice Prediction</title>

  <!-- Bootstrap core CSS -->
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Custom styles for this template -->
  <link href="css/scrolling-nav.css" rel="stylesheet">

</head>

<body id="page-top">

  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top" id="mainNav">
    <div class="container">
      <a class="navbar-brand js-scroll-trigger" href="#page-top">Sea Ice Prediction</a>
      <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarResponsive">
        <ul class="navbar-nav ml-auto">
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="#background">배경</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="#techstack">기술스택</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="#CNN">CNN</a>
          </li>
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="#RNN">RNN</a>
          </li>
        </ul>
      </div>
    </div>
  </nav>

  <header class="bg-primary text-white">
    <div class="container text-center">
      <h1>위성 영상을 활용한 북극 해빙 예측 AI 경진대회</h1>
      <p class="lead">CNN, RNN, RESNet, VGGNet 모델을 통한 예측</p>
    </div>
  </header>

  <section id="background">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 mx-auto">
          <h2>프로젝트 배경</h2>
          <img src="https://t1.daumcdn.net/cfile/blog/2442C5395688CF481F" width="40%" style="display: block; margin: 0 auto;">
          <p class="lead">
            <p>2015년 선진국과 개도국이 모두 참여하는 '파리 협정'에서 기후변화 문제의 심각성을 인지하고 지구 평균온도 상승을 2℃ 보다 아래로 유지하고 나아가 1.5℃로 억제하기 위한 협약을 맺었다.
            이를 실행하기 위해선 2050년까지 탄소 순배출량이 0가 되는 탄소중립 사회로의 전환이 필요하다.</p>

​	           <p>지구 온난화가 얼마나 심한 상황인지 직관적으로 인지하기 위해 분석할만한 데이터를 찾아보다가 데이콘과 극지연구소에서 주최하는 '위성 영상을 활용한 북극 해빙 예측 AI 경진대회' 에 참여하기로 하였다.</p>

​	           <p>위 대회에서 제공하는 1978년~2018년 월별 482개의 북극 해빙농도 자료를 통해 2019년~2020년 월별 24개의 데이터를 예측하는 모델을 제출해야 한다. 이를 통해 우리는 지구 온난화의 영향으로 면적이 얼마나 줄어들고 있는지 확인할 수 있고, 더 나아가 미래의
  해빙농도에 대해 예측하여 기후재앙의 심각성을 재고할 수 있다</p>
          </p>
          <ul>
            <li>북극은 지구에서 그 어느 지역보다도 온난화가 가장 빠르게 진행되고 있는 지역</li>
            <li>매년 여름철 북극 빙량은 급격히 줄어든다.</li>
            <li>2020년 9월의 북극 빙량 최저치는 374만㎢로 위성 관측이 시작된 1979년 이래 두 번째로 400만㎢선이 무너져서 2012년의 다음으로 관측 사상 빙량 최저순위 2위를 기록</li>
            <li>Minimal custom CSS so you are free to explore your own unique design options</li>
          </ul>
        </div>
      </div>
    </div>
  </section>

  <section id="techstack" class="bg-light">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 mx-auto">
          <h2>AWS Ubuntu Apache를 통해 배포</h2>
          <h3><br>Apache vs Nginx</h3>
          <p class="lead">
            <h4>Apache<br></h4>
            <p>스레드/ 프로세스 기반 구조, 클라이언트 요청 하나당 스레드 하나가 처리하는 구조.</p>
            <h5><br>1.PreFork 방식</h5>
              <img src = "https://taetaetae.github.io/images/apache-vs-nginx/prefork.gif">
              <ul>
                <br>
                <li>Client 요청에 대해 apache 자식 프로세스를 생성하여 처리합니다.</li>
                <li>요청이 많을 경우 Process 를 생성하여 처리합니다. 이 방식은 Apache 설치시 default 로 설정되어 있습니다.</li>
                <li>하나의 자식프로세스당 하나의 스레드 를 갖습니다. (최대 1024개)</li>
                <li>스레드간 메모리 공유를 하지 않습니다. 이 방식은 독립적이기에 안정적인 반면, 메모리 소모가 크다는 단점이 있습니다.</li>
              </ul>
            <h5><br>2.Worker MPM 방식</h5>
              <img src = "https://taetaetae.github.io/images/apache-vs-nginx/worker.gif">
              <ul>
                <br>
                <li>Prefork 보다 메모리 사용량이 적고 동시접속자가 많은 사이트에 적합합니다. 각 프로세스의 스레드를 생성해 처리하는 구조입니다.</li>
                <li>스레드 간의 메모리 공유가 가능합니다.</li>
                <li>프로세스 당 최대 64개의 스레드처리가 가능하며, 각 스레드는 하나의 연결만을 부여받습니다.</li>
              </ul>
            <h4>Nginx</h4>
            <img src = "https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FnsMYW%2FbtqxGaQTl6O%2FzQwB8vDmOaadPSRnzHIYRk%2Fimg.png">
            <p><br>Apache의 동시 접속자수가 1만명이 넘어갈 때의 문제점(C10K Problem)을 해결하기 위해 만들어진 비동기 `Event-Driven ` 구조의 웹서버 소프트웨어 사용이 매우 심플하고 규모가 작은 서비스이면서 정적 데이터 처리가 많은 서비스에 적합</p>
            <ul>
              <br>
              <li>NginX는 스레드를 많이 사용하지 않기 때문에 context Switching 비용이 적고 CPU 소모도 낮습니다.</li>
              <li>적은 수의 스레드로 효율적으로 일 처리하며, 스레드당 할당되는 메모리도 적게 사용하는 구조 입니다. </li>
              <li>Event-Driven 처리 방식을 사용하다 보니 프로세스를 Fork 하거나 스레드를 사용하는 아파치와 달리 CPU와 관계없이 모든 IO들을 전부 Event Listener로 미루기 때문에 흐름이 끊기지 않고 응답이 빠르게 진행이 되어 1개의 프로세스로 더 빠른 작업이 가능하게 될 수 있습니다.</li>
            </ul>
              <img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FlFdAx%2FbtqxEP7wfLv%2F7zSjsmR1KQ6iq0j7DCAqOK%2Fimg.png" width="120%" style="display: block; margin: 0 auto;">
          </p>
        </div>
      </div>
    </div>
  </section>

  <section id="CNN">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 mx-auto">
          <h2>CNN(Convolutional Neural Networks)</h2>
          <p class="lead">
            <br>
            <h3>1.CNN 무엇일까?</h3>
            <p>Convolution 이라는 전처리 작업이 들어가는 Neural Network 모델, 기존의DNN(Deep Neural Network) 은 1차원 형태의 데이터만 사용하기 때문에 공간,지역 정보가 손실된다. 추상화 과정없이 연산과정으로 넘어가 학습효율이 떨어진다.</p>
            <p>이를 보완하기 위해 raw input을 그대로 받아서 공간,지역 정보의 feature들의 계층을 빌드업한다. CNN은 이미지 전체보다는 부분을 보고 한 픽셀과 주변 픽셀들의 연관성을 살린다.</p>
            <img src ="https://miro.medium.com/max/1058/1*NFsuKOLUultX5U2wb_OpXQ.png" width="100%">
            <p>예를 들어 우리는 어떠한 이미지가 주어졌을때 이것이 새의 이미지인지 아닌지 결정할 수 있는 모델을 만들고 싶다고 가정합시다.모델이 전체 이미지를 보는 것 보다는 새의 부리 부분을 잘라 보는게 더 효율적이겠죠? 그것을 해주는것이 CNN입니다. CNN의 뉴런이 패턴(이 경우에서는 새의 부리)을 파악하기 위해서 전체 이미지를 모두 다 볼 필요가 없습니다.</p>
            <br><br>

            <h3>2.CNN의 주요 컨셉들</h3>
            <h4>Convolution의 작동 원리</h4>
            <img src="https://miro.medium.com/max/1748/1*s6yBccVNHVuEEO9Ur6Az9w.png" width="100%">
            <h5>Zero Padding</h5>
            <p>Convolution 과정을 거치게 되면 5x5 크기의 이미지가 3x3으로 줄어들게된다. 이를 해결하기 위해서 Padding 을 통해 테두리를 0으로 감싸준다. 입력값의 크기 7X7로 변경되어 결과값의 크기가 5X5로 기존 이미지와 같아진다.</p>
            <h5>Stride</h5>
            <p>필터를 얼만큼 움직일 것인가에 대한 값. 기본값은 1이다.</p>
            <br><br>

            <h3>3.CNN의 전체적인 네트워크 구조</h3>
            <img src="https://miro.medium.com/max/960/1*usA-K08Tn5i6P7eLvV8htg.png" width="100%">
            <br><br>
            <h5>Convolutional Layer</h5>
            <img src="https://miro.medium.com/max/1685/1*E-5sL3jJMIygx0Xm9_y6Ew.png" width="100%">
            <p>28x28 크기의 이미지를 여러개의 Filter을 통해 결과값을 구한다. 그림의 예시로 보면 10개의 24x24 output에 Activation Function을 통해 Convolutional Layer을 완성한다.</p>
            <h5>Pooling Layer</h5>
            <img src="https://miro.medium.com/max/1685/1*wGrlfRciYNcqhGqBWSiErg.png" width="100%">
            <p>Pooling은 이미지의 output의 갯수가 너무 많아져서 생기는 문제를 방지해줌.            각 결과값의 dimentionality를 축소해주는 목적을 가짐. correlation이 낮은 부분을 제거하여 dimension을 축소시킨다.</p>
            <img src="https://miro.medium.com/max/774/1*8DRW7Uw6lHfAdPdXrHiY9w.png" width="100%">
            <h5>Flatten(Vectorization)</h5>
            <img src="https://miro.medium.com/max/1682/1*v8TDECzNYJBrsSvlSLTcNg.png" width="100%">
            <p>4x4x20의 텐서를 일자 형태의 데이터로 펴준다.<br>320 - dimension을 가진 vector 형태로 바뀌게 된다.<br><br>두번째 Pooling Layer을 통해서 4x4 크기의 이미지들은 입력된 이미지에서 얻어온 특이점 데이터가 되어 1차원의 벡터 데이터로 변형시켜주어도 무관하다.</p>
            <h5>Fully-Connected Layers(Dense Layers)</h5>
            <img src="https://miro.medium.com/max/1680/1*EcOvxbhodURWEjXXepKYIw.png" width="100%">
            이제 마지막으로 FC Layer을 통해 Softmax activation function을 적용해주면 최종 결과물을 출력하게 된다.
          </p>
        </div>
      </div>
    </div>
  </section>

  <section id="RNN">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 mx-auto">
          <h2>RNN(Recurrent Neural Networks)</h2><br>
          <p class="lead">
            <h3>1.RNN 무엇일까?</h3>
            <p>순차적으로 등장하는 데이터 처리에 적합한 모델.<br><br>RNN이 기존의 뉴럴 네트워크와 다른 점은 ‘기억’(다른 말로 hidden state)을 갖고 있다는 점입니다. 네트워크의 기억은 지금까지의 입력 데이터를 요약한 정보라고 볼 수 있습니다.<br><br>시퀀스의 길이에 관계없이 인풋과 아웃풋을 받아들일 수 있는 구조라 유연하게 구조를 만들 수 있다.</p>
            <img src="https://files.slack.com/files-pri/T25783BPY-F6YUKQKCP/rnn-diagram.png?pub_secret=9e9b7d3f1e" width="80%">
            <p>위 다이어그램에서 빨간색 사각형은 `입력`, 노란색 사각형은 `기억`, 파란색 사각형은 `출력`을 나타냅니다. 첫번째 입력이 들어오면 첫번째 기억이 만들어집니다. 두번째 입력이 들어오면 기존의 기억과 새로운 입력을 참고하여 새 기억을 만듭니다. 입력의 길이만큼 이 과정을 얼마든지 반복할 수 있습니다. 각각의 기억은 그때까지의 입력을 요약해서 갖고 있는 정보입니다. RNN은 이 요약된 정보를 바탕으로 출력을 만들어 냅니다.</p>
            <br><br>
            <img src="http://i.imgur.com/Q8zv6TQ.png" width="100%">
            <ol>
              <br>
              <li>고정크기 입력 & 시퀀스 출력.<br>예) 이미지를 입력해서 이미지에 대한 설명을 문장으로 출력하는 이미지 캡션 생성</li>
              <br>
              <li>시퀀스 입력 & 고정크기 출력.<br>예) 문장을 입력해서 긍부정 정도를 출력하는 감성 분석기</li>
              <br>
              <li>시퀀스 입력 & 시퀀스 출력.<br>예) 영어를 한국으로 번역하는 자동 번역기</li>
            </ol>
            <br>
            <h3>2.RNN의 한계점</h3>
            <h5>장기 의존성(Long-Term Dependency) 문제점</h5>
            <p>가끔, 우리는 최근 데이터를 가지고 현재의 문제를 해결해야하는 상황에 직면하게 됩니다. 예를 들어서, 이전 단어 선택을 활용하여 다음에 입력될 단어를 예측하는 언어 모델을 생각해봅시다. 만약에 우리가 "the clouds are in the sky,"라는 문장에서 "the clouds are in the"라는 입력값을 받고 마지막 단어를 예측해야 한다면, 우리는 더 이상 문맥이 필요하지 않습니다. 명확하게 다음에 입력될 단어는 "sky"가 될 확률이 높습니다. 이러한 경우에 제공된 데이터와 배워야 할 정보의 입력 위치 차이(Gap)가 크지 않다면, RNN은 과거의 데이터를 기반으로 학습을 할 수 있게 됩니다.</p>
            <img src="https://t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/IgT/image/4mQRpbvw6CfP7BPmEDwaGouueEs.png" width="100%">
            <p>하지만, 우리는 더 많은 문맥이 필요할 때가 있습니다. 예를 들어 "I grew up in France... I speak fluent French.(나는 프랑스에서 자라났어... 나는 프랑스어를 유창하게 해)"라는 문장에서 마지막 단어 French(프랑스어)를 예측하는 문제를 생각해보겠습니다. 최근 정보를 기반으로 예측 모델은 다음 단어가 아마도 언어의 한 종류라고 예측될 것입니다. 그렇다면, 이 예측 모델은 "I grew up in France(나는 프랑스에서 자라났다)"에서 프랑스라는 문맥이 필요하게 됩니다. 실제로 "I grew up in France(프랑스에서 자라났다)"는 표현과 "I speak fluent (나는 언어를 유창하게 한다)"라는 표현의 위치가 멀어지는 문제는 아주 빈번하게 발생합니다.</p>

            <h3>3. LSTM(Long Short Term Memory networks)</h3>
            <p>LSTM은 장기 의존성 문제를 해결하기 위해 명시적으로 디자인되었습니다. 오랜 기간동안 정보를 기억하는 일은 LSTM에 있어 특별한 작업없이도 기본적으로 취하게 되는 기본 특성입니다. 장기 의존성 문제를 풀려고 특별히 열심히 노력할 필요가 없습니다.</p>
            <img src="https://t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/IgT/image/I0UJ8f2U5ePsX3LU-kJS--yIarU.png" width="100%">
            <img src="https://t1.daumcdn.net/thumb/R1280x0/?fname=http://t1.daumcdn.net/brunch/service/user/IgT/image/g-NiohVI_BwATq4Uvt7gBPv4IWs.png" width="100%">
            <p>위 다이어그램에서 각 라인은 온전한 vector를 포함합니다. 각 출력값은 다른 노드의 입력값이 됩니다. 분홍색 원은 점단위의 연산을 표현합니다(예를 들어, 벡터 더하기 연산이 있습니다.) 그리고 노란색 박스는 뉴럴 네트워크의 단위입니다. 하나로 합쳐지는 4번째 기호는 집중을 의미합니다. 반면에 하나의 화살표가 두개로 나눠지는 5번째 기호는 결과값이 서로 다른 두 노드에 복사되는 것을 의미합니다.</p>
          </p>
        </div>
      </div>
    </div>
  </section>

  <!-- Footer -->
  <footer class="py-5 bg-dark">
    <div class="container">
      <p class="m-0 text-center text-white">Copyright &copy; Our Website 2021</p>
    </div>
    <!-- /.container -->
  </footer>

  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  <!-- Plugin JavaScript -->
  <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

  <!-- Custom JavaScript for this theme -->
  <script src="js/scrolling-nav.js"></script>

</body>

</html>
